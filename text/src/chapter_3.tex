\section{Реализация Class-Based WFQ в ядре Linux}

	\subsection{Управление трафиком}

	Расскать про traffic control (tc) и как он связан с конфигурацией qdisc + Netlink.

	\subsection{Описание устройства подсистемы планировки в ядре Linux}
	% Информация из комментариев к ним.
	% Файлы: linux/net/sched/sch_api.c, linux/include/net/{sch_generic.h,pkt_sched.h}. 

	[Схема пути пакета]

	В ядре сетевое устройство описывается структурой \lstinline{struct net_device},
	которая содержит указатель на ассоциированную с устройством дисциплину обслуживания,
	описываемая структурой \lstinline{struct Qdisc}.

	Опишем важные для понимания подсистемы поля \texttt{Qdisc}.
	\begin{itemize}
		\item enqueue
	\end{itemize} 

	
	В общем, дисциплина обслуживания -- это чёрный ящик, который может
	ставить пакеты в очереди и вынимать их из очереди, когда устройство
	готово к отправке, в порядка и во время, определёнными спрятанным в ящике
	алгоритмом. В ядре Linux дисциплины обслуживания представляются в качестве
	модулей ядра, которые реализуют предоставляемый ядром интерфейс.

	API предосавтляет две функции: \lstinline{register_qdisc(struct Qdisc_ops *ops)}
	и обратную -- \lstinline{unregister_qdisc(struct Qdisc_ops *ops)}, которые регистрируют
	и разрегистрируют дисциплину обслуживания. Важно отметить, что обе эти
	функции принимают в качестве аргумента структуру \lstinline{struct Qdisc_ops},
	которая явным образом идентифицирует дисциплину обслуживания в ядре.

	Структура \texttt{Qdisc\_ops} помимо метаинформации содержит указатели на функции,
	которые должен реализовывать модель дисциплины обслуживания для корректной
	работы в ядре. 

	Следующие функции определяют работу алгоритма.
	\begin{itemize}
		\item \lstinline{enqueue}\\
   		    \lstinline{int enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free);} \\
			Фукнкция добавляет пакет в очередь. Если пакет был отброшен, функция
			возращает код ошибки, говорящий о том, был отброшен пришедший пакет или
			иной, чьё место занял новый.
		\item \lstinline{dequeue}\\
			\lstinline{struct sk_buff *dequeue(struct Qdisc * sch);}
			Функция, возвращающая пакет из очереди на отправку. Дисциплина
			может не передавать пакет при вызове этой функции по решению
			алгоритма, в таком случае вернув нулевой указатель; 
			однако то же значение алгоритм возвращает в случае, если очередь
			пуста, поэтому в таком случае дополнительно проверяется длина
			очереди.
		\item \lstinline{peek}\\
			\lstinline{struct sk_buff *peek(struct Qdisc * sch);}
			Функция возвращает пакет из очереди на отправку, не удаляя его из реальной очереди,
			как это делает функция \lstinline{dequeue}.
	\end{itemize}

	Следующие функции определяют настройки алгоритма.
	\begin{itemize}
		\item \lstinline{init}\\
			  \lstinline{int init(struct Qdisc *sch, struct nlattr *arg);}\\
			  Функция инициализирует вновь созданный экземпляр дисциплины обслуживания \texttt{sch}.
			  Вторым аргументом функции является конфигурация дисциплины обслуживния, передаваемая
			  в ядро с помощью подсистемы Netlink.
		\item \lstinline{change}\\
			  \lstinline{int change(struct Qdisc *sch, struct nlattr *arg);}\\
			  Функция изменяет текущие настройки дисциплины обслуживания. 
	\end{itemize}

	Дополнительно рассказать про классификаторы.

	Таким образом при составлении алгоритма CBWFQ явный упор должен делаться на том, как выражается
	ДО в ядре через \lstinline{enqueue} и \lstinline{dequeue}.

	\subsection{Алгоритм CBWFQ}
	
		\subsubsection{Стркутура хранения данных Class-Based WFQ}

		\subsubsection{Псевдокод}

			Описать enqueue, classify и drop. Все реализуют drop двумя способами: через qdisc\_drop() и через
			if net\_xmit\_drop\_count() \{ qdisc\_qstat\_drop(sch) \}. 

			\begin{algorithmic}
				\Function{dequeue}{Q}
					\State {sort\_queues\_by\_time(Q)}
					\State {q $\gets$ Q$_1$}
					\State \Return \Call{qdisc\_dequeue}{q}
				\EndFunction
			\end{algorithmic}

			\begin{algorithmic}
				\Function{enqueue}{Q, pkt}
					\State {// Сначала нужно классифицировать пакет в очередь}
					\State q $\gets $ \Call{classify}{Q, pkt}
					\State {//Если количество пакетов в очереди не превосходит пороговых значений,}
					\State {//то мехнизм отбрасывания не запускается.}
					\State {//Иначе следует запустить соответствующий мехнизм отбрасывания.}
					\State {//Так как мехнизмы довольно схожи, их вычисление можно объединить.}
    				\If {$\text{q.count} < \text{HQO} \land \text{q.count} < \text{CDT}$}
        				\State \Call{qdisc\_enqueue}{q, pkt}
					\ElsIf {pkt.time has the worst finish time}
						\State \Call{qdisc\_drop}{pkt}
					\Else
						\If {q.count $>$ HQO }
							\State {$\text{p}_1 \gets \text{get\_worst\_finish\_time(q)}$}
							\State \Call {qdisc\_drop}{p$_1$}
						\EndIf
							\State \Call {qdisc\_enqueue}{q, pkt}
					\EndIf
				\EndFunction
			\end{algorithmic}

			\begin{algorithmic}
				\Function{classify}{Q, pkt}
					\State {// TODO}
				\EndFunction
			\end{algorithmic}

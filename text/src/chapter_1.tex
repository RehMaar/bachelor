\section{Обзор существующих решений}

	\subsection{PQ}

    Самый простой метод обеспечения дифференцированного обслуживания. Эта техника
    использует множество очередей. Очереди обслуживаются с разными видами приоритетов
    и очереди с более высоким приоритетом обслуживаются в первую очередь. Пакеты
    помещаются в одну из очередей в соответствии с их классификацией. Пакеты
    обрабатываются из одной очереди, только если очереди с более высокими приоритетами
    пусты. Внутри очередей пакеты обрабатываются в порядке FIFO. В случае переполнения
    отбрасываются пакеты из очереди с более низким приоритетом. [packethandling.pdf]

	[image]


	Приемущества.
	\begin{itemize}
		\item Для software-based маршрутизаторов PQ предоставляет относительно небольшую
             вычислительную нагрузку на систему в сравнении с более сложными ДО.
		\item PQ позволяет маршрутизаторам организовывать буферизацию пакетов и обслуживать
             один класс трафика отдельно от других.
	\end{itemize}


	Недостатки.
	\begin{itemize}
		\item Если количество высокоприоритизированного трафика стало избыточным,
            низкоприоритезированный трафик будет отбрасываться.
		\item Избыточный (misbehaving) высокоприоритетный трафик может значительно увеличивать
                задержку (delay) и джиттер (jitter) для другого высокоприоритетного трафика.
		\item Не решается проблема с TCP и UDP, когда TCP-трафику даётся высокий приоритет и он
                пытается поглотить всю пропускную способность (bandwidth).
	\end{itemize}



	\subsection{CBQ}

        Class Based Queueing (CBQ) -- это классовая дисциплина обслуживания, которая реализует
        богатое иерархическое разделение канала между классами (rich link sharing hierarchy of
        classes). [man tc-cbq]

        Главная идея за CBQ -- это планировка пакетов в очередях и гарантия определённой
        скорости передачи. Если в очереди нет пакетов, её пропускная способность
        становится доступной для других очередей. Сила этого метода состоит в том, что
        он позволяет справляться (among flows) со значительно различными требованиями
        к пропускной способности канала (bandwidth). Это сделано путём назначения
        определённого процента
        Link bandwidth каждой очереди. CBQ также избегает проблему застоя пропускной способности
        (bandwidth starvation) с помощью PQ метода, так как по крайней мере один пакет обслуживается
        из каждой очереди в течение service round.

        Алгоритм CBQ состоит в следующем. Сначала пакеты классифицируются в классы
        обслуживания в соответствии с определёнными критериями и сохраняются в
        соответствующей очереди. Очереди обслуживаются циклически (round robin). Различное
        количество пропускной способности может быть назначено для каждой очереди
        двумя различными способами: с помощью позволения очереди отправлять более
        чем один пакет на каждый цикл обслуживания или с помощью позволения очереди
        отправлять только один пакет за цикл, но при этом очередь может быть обслужена
        несколько раз за цикл.

        Преимущества.
		\begin{itemize}
        	\item Позволяет контролировать количество пропускной способности для каждого
                класса обслуживания.
        	\item Каждый класс получает обслуживание, вне зависимости от других классов. Это
                помогает избегать проблемы PQ, когда при избытке высокоприоритезированного
                трафика низкоприоритезированный не обслуживался вообще.
		\end{itemize}
        Недостатки.
		\begin{itemize}
            \item Честное выделение пропускной способности (fair allocation bandwidth) происходит, только если
        пакеты из всех очередей имеют сравнительно одинаковый размер. Если один класс
        обслуживания содержит пакет, который длиннее остальных, этот класс обслуживания
        получит большую пропускную способность (bandwidth), чем сконфигурированное значение.
		\end{itemize}
        %(Более полное описание есть в man tc-cbq, ругают в http://tldp.org/HOWTO/Adv-Routing-HOWTO/lartc.qdisc.classful.html
        %судя по http://web.opalsoft.net/qos/default.php?p=ds-28).

	\subsection{HTB}

        Hierarchical Token Bucket (HTB) -- ДО с иерархическим разделением канала между классами. HTB
        состоит из произвольного числа иерархически организованных TBF (token bucket filter). HTB
        позволяет создать динамическую структуру разделения канала основанного
        на дереве, где узел определяет класс, а его потомки -- некоторый подкласс;
        каждому классу выделяется пропускная способность, которая разделяется между
        подклассами. Если подкласс не использует назначенную пропускную способность,
        она распределяется между его соседями; если на более высоком уровне иерархии
        класс не использует всю пропускную способность, она распределяется уже между
        соседями этого класса. Сами очереди содержатся в листьях дерева.

		Приемущества.
		\begin{itemize}
			\item Иерархическая структура предоставляет гибкую возможность конфигурировать трафик.
            \item Не зависит от характеристик интерфейса и не нуждается в знании о лежащей в основе пропускной способности выходного интерфейса [man tc-htb].
		\end{itemize}

		Недостатки.
		\begin{itemize}
			\item Видимо, связаны с TBF.
		\end{itemize}

	\subsection{HFSC}

% https://www.cs.cmu.edu/~hzhang/papers/SIGCOM97.pdf
% http://linux-tc-notes.sourceforge.net/tc/doc/sch_hfsc.txt
% https://serverfault.com/questions/105014/does-anyone-really-understand-how-hfsc-scheduling-in-linux-bsd-works


        HFSC -- Hierarchical Fair-Service Curve -- иерархический алгоритм планирования пакетов,
        основанный на математической модели честных кривых обслуживания (Fair Service Curve),
        где под термином “кривая обслуживания” подразумевается зависящая от времени
        неубывающая функция, которая служит нижней границей количества обслуживания,
        предоставляемого системой [из сетевого исчисления, ссылка на какой-либо ресурс
        такого рода].

	
        HFSC ставит перед собой цели:
		\begin{itemize}
            \item гарантировать точное выделение пропускной способности и задержки для всех листовых классов (критерий реального времени);
            \item честно выделять избыточную пропускную способность как указано классовой иерархией (критерий разделения канала);
            \item минимизировать несоответствие кривой обслуживания идеальной модели и действительного количество обслуживания. [man 7 tc-hfsc]
		\end{itemize}

        Алгоритм планировки основан на двух критериях: критерий реального времени
        (real-time) и критерий разделения канала (link-sharing). Критерии реального времени
        используются для выбора пакета в условиях, когда есть потенциальная опасность,
        что гарантия обслуживания для листового класса нарушается. В ином случае
        используется критерий разделения канала.

        HFSC использует три типа временных параметров: время крайнего срока (deadline
        time), <<подходящее>> время (eligible time) и виртуальное время (virtual time). Время крайнего
        срока назначается таким образом, чтобы, если крайние сроки всех пакетов сессии
        выполнены, его кривая была гарантирована. <<Подходящее>> время используется для
        выбора критерия планировки для следующего пакета. Виртуальное время показывает
        нормализованное количество обслуживания, которое получил класс. Виртуальное
        время присуще всем вершинам дерева классов, так как является важным параметром
        при критерии разделение канала, при котором должно минимизироваться
        несоответствие между виртуальным временем класса и временами его соседей
        (так как в идеальной модели виртуальное время соседей одинаково); при выборе
        критерия разделения канала алгоритм рекурсивно, начиная с корня, обходит всё
        дерево, переходя в вершины с наименьшим виртуальным временем. Время крайнего
        срока и <<подходящее>> время используются дополнительно в листьевых классах,
        так как в этих вершинах непосредственно содержатся очереди. [SIGCOM97.pdf, описать
        более вразумительно].

        Преимущества.
		\begin{itemize}
            \item Алгоритм основан на формальной модели с доказанными нижними границами.
		\end{itemize}

        Недостатки.
		\begin{itemize}
            \item Сложность.
		\end{itemize}

	\subsection{WFQ based on flow}

    WFQ страдает от нескольких недостатков.
	\begin{itemize}
    	\item  Трафик не может регулироваться на основе пользовательски определённых классов.
    	\item  WFQ не может предоставить конкретную гарантируемую пропускную способность для потока трафика.
    	\item  WFQ только поддерживается на медленных каналах.
	\end{itemize}
% http://www.routeralley.com/guides/qos_queuing.pdf

    Эти ограничения были исправлены CBWFQ. CBWFQ предоставляет 64 определяемые
    пользователями очереди. Трафик внутри очереди обрабатывается с помощью FIFO
    (проверить). Каждой очереди предоставляется с конфигурируемым минимумом.

	\subsection{Class-Based WFQ}

	% https://www.cisco.com/en/US/docs/ios/12_0t/12_0t5/feature/guide/cbwfq.html

    CBWFQ (Class-based weighted fair queueing) -- основанный на классах алгоритм взвешенных честных
    чередей; является расширением функциональности ДО WFQ, основанной на потоках, для предоставления
    определяемых пользователями классов трафика. Он поддерживает
    определение пользовательских классов трафика на основе ряда критериев соответствия
    (протокол, входящий интерфейс и т.д.) и назначение их характеристик, которые
    отвечают за выделяемые классу ресурсы (вес, пропускная способность, максимальное
    количество пакетов в очереди, задержка). Такой подход предоставляет гибкую настройку
    распределения пропускной способности канала между классами трафика.

	Для Class-Based WFQ класс трафика определяется на основе заданных криетриев
	соответствия: протокол, входящий интерфейс и т.п. Пакеты, удовлетворяющие
	криетриям класса, составляют трафика для этого класса.

	После определения класса, ему назначаются характеристики, которые определяют
	политику очереди: пропускная способность, выделенная классу, максимальная
	длина очереди и так далее. Пропускная способность является гарантированной,
	то есть гарантированно предоставляется классу в течение перегрузки. 

	В качестве политики отбрасывания пакетов по умолчанию,используется отбрасывание конца
	очереди (tail-drop), однако допускается использовать
	алгоритм взвешенного произвольного раннего обнаружения (Weighted Random Early Detection, WRED).

	
    [вставить картинку]


	% [link]

	%Для CBWFQ класс трафика определяется
    %на основе критериев соответствия, которые могут включать в себя протокол,
    %список контроля доступа (ACL) и входящий интерфейс. Пакеты, удовлетворяющие
    %критериям для класса, составляют трафик для этого класса. После определения
    %класса критериями соответствия, ему назначаются характеристики: пропускная
    %способность, вес, максимальная длина очереди и максимальное количество
    %пакетов. Пропускная способность, которая назначается классу, является
    %гарантированной и предоставляется классу в течение перегрузки.

